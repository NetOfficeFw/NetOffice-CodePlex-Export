<?xml version="1.0" encoding="utf-8"?>
<CodeplexIssue xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Id>20313</Id>
  <Title>ExcelApi.Application.GetActiveInstances returns the same Instances</Title>
  <DescriptionHtml xml:space="preserve"><![CDATA[I open 2 Excel Applications, then I iterate through the result array of ExcelApi.Application.GetActiveInstances.

Each of the 2 returned Application has the same result for hwnd. So both Application objects refer to the first Excel.

I use Windows 7 and NetOffice 1.6.0]]></DescriptionHtml>
  <Status>Active</Status>
  <Type>Unassigned</Type>
  <Impact>Unassigned</Impact>
  <Comments>
    <CodeplexComment>
      <Author>SebastianDotNet</Author>
      <BodyHtml xml:space="preserve"><![CDATA[I confirm the issue and i do some some tests and research and the main problem is IRunningObjectTable::GetObject does soemethin wrong(returns wrong instance
<a href="http://www.tech-archive.net/Archive/Development/microsoft.public.win32.programmer.ole/2004-09/0121.html" rel="nofollow">
http://www.tech-archive.net/Archive/Development/microsoft.public.win32.programmer.ole/2004-09/0121.html</a>). I currently looking for a solution.


*Sebastian]]></BodyHtml>
      <CreatedAt>2013-10-16T04:46:42.0000000+02:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>panewman</Author>
      <BodyHtml xml:space="preserve"><![CDATA[Maybe going through windows is a solution.This gets the first Application, but you could easily loop through every XLMAIN window. This does fail, if there is no ExcelApi.Window (EXCEL7).```IntPtr w = FindWindowEx(IntPtr.Zero, IntPtr.Zero, "XLMAIN",
 null); Console.WriteLine(w);
<pre><code>        IntPtr w1 = FindWindowEx(w, IntPtr.Zero, "XLDESK", null);            Console.WriteLine(w1);

        IntPtr w2 = FindWindowEx(w1, IntPtr.Zero, "EXCEL7", null);            Console.WriteLine(w2);

        Guid guid = new Guid("{00020400-0000-0000-C000-000000000046}");            object obj = null;            int retVal = AccessibleObjectFromWindow(w2, (uint)0xFFFFFFF0, ref guid, ref obj);            Console.WriteLine(obj.ToString() + " " + TypeDescriptor.GetClassName(obj) + " " + TypeDescriptor.GetComponentName(obj));            NetOffice.ExcelApi.Window wind = new NetOffice.ExcelApi.Window(null, obj);            NetOffice.ExcelApi.Application appl = wind.Application;

        Console.WriteLine(appl.Name + " " + wind.Caption);

        wind.Dispose();```</code></pre>]]></BodyHtml>
      <CreatedAt>2013-10-17T20:11:35.0000000+02:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>SebastianDotNet</Author>
      <BodyHtml xml:space="preserve"><![CDATA[thanks for reply. you use can EnumWindow to enumerate all the open window handles (but this solution may doesnt works gladly when the current appdomain doesnt have elevated permissions). currently i try to find a solution in my books about about the COM
 standard(very old books man) if its failed i want spend a solution in the win api way(gimme 2 days more)]]></BodyHtml>
      <CreatedAt>2013-10-17T21:55:04.0000000+02:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>SebastianDotNet</Author>
      <BodyHtml xml:space="preserve"><![CDATA[i create a concept test today. you find this in latest source state: Tests\Concept Tests\ObjectFromWindow


i have to test this in serveral virtual machines(all excel versions from 2000-2013) and when its good i change the GetActiveInstances implementation in Excel.Application immediately.


*Sebastian]]></BodyHtml>
      <CreatedAt>2013-10-27T02:45:30.0000000+01:00</CreatedAt>
    </CodeplexComment>
  </Comments>
  <ReportedBy>panewman</ReportedBy>
  <ReportedAt>2013-10-15T08:24:17.0000000+00:00</ReportedAt>
</CodeplexIssue>