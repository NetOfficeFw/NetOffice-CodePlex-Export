<?xml version="1.0" encoding="utf-8"?>
<CodeplexIssue xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Id>21697</Id>
  <Title>NetOffice.OutlookAPI.Items.Sort() is erroring with an Out of Memory exception.</Title>
  <DescriptionHtml xml:space="preserve"><![CDATA[When reading calendar appointments from Outlook, there's an option called "IncludeRecurrences" that should add all future recurrences to the list of items. For example: if I have a recurring appointment that happens every Wednesday, when my list
 of appointments return, I should see a future entries for my Wednesday appointment.

This works great using the Office.Interop, but when I switch my code to NetOffice, I receive an error message after I set IncludeRecurrences to true, and then try and Sort. The Sort() method does not work correctly, and errors out saying "Exception of
 type 'System.OutOfMemoryException' was thrown."

Here is the stack trace:
((System.Exception)((new System.Linq.SystemCore_EnumerableDebugView<object>(OutlookItems)).Items)).StackTrace at NetOffice.OutlookApi._Items.d__7.MoveNext() at NetOffice.OutlookApi._Items.d__0.MoveNext() at System.Linq.SystemCore_EnumerableDebugView`1.get_Items()

Would it be possible to make this work similar to the Office.Interop?

Here is my code:
<pre><code>    public List<Appointment> GetAppointmentsInRange()
    {
        var result = new List<Appointment>();

        Items OutlookItems = outlookCalendar.Items as Items;
        OutlookItems.IncludeRecurrences = true;
        OutlookItems.Sort("[Start]");

        if (OutlookItems != null)
        {
            DateTime min = DateTime.Now.AddDays(-1);
            DateTime max = DateTime.Now.AddDays(+30);

 string filter = "[End] >= '" + min + "' AND [Start] < '" + max + "'";

            var filteredAppoinments = OutlookItems.Restrict(filter);
            foreach (AppointmentItem ai in filteredAppoinments)
            {
                result.Add(GetOutlookAppointment(ai));
            }
        }
        return result;
    }</code></pre>]]></DescriptionHtml>
  <Status>Proposed</Status>
  <Type>Unassigned</Type>
  <Impact>Unassigned</Impact>
  <Comments>
    <CodeplexComment>
      <Author>dgoodw01</Author>
      <BodyHtml xml:space="preserve"><![CDATA[Here is a screenshot of the error message in Visual Studio.]]></BodyHtml>
      <CreatedAt>2015-01-29T23:15:18.0000000+01:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>SebastianDotNet</Author>
      <BodyHtml xml:space="preserve"><![CDATA[The Enumerator in Outlook.Items is a custom NetOffice enumerator.This is a special NO service for scenarios with a low amount of data.


Microsoft doesnt spend an enumerator here because the count of items(mails or whatever) was too big to handle this completly in local memory. (typical in an Exchange scenario)


so you have to use the low level enumerator methods. (GetNext, etc.) and sort them at hand.


*Sebastian]]></BodyHtml>
      <CreatedAt>2015-02-06T22:10:44.0000000+01:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>dgoodw01</Author>
      <BodyHtml xml:space="preserve"><![CDATA[Sebastian, 

Could you give me an example of how to sort them at hand, using a low level enumerator? I can't seem to figure it out. Any help you can provide is greatly appreciated.]]></BodyHtml>
      <CreatedAt>2015-02-07T05:06:32.0000000+01:00</CreatedAt>
    </CodeplexComment>
    <CodeplexComment>
      <Author>SebastianDotNet</Author>
      <BodyHtml xml:space="preserve"><![CDATA[this is the common way for example:(<a href="https://msdn.microsoft.com/en-us/en-us/library/office/ff860338.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/en-us/library/office/ff860338.aspx</a>)


object item = inboxFolder.Items.GetFirst();while (null != item){ item = inboxFolder.Items.GetNext();}


nice to know, the NetOffice custom enumerator:[from NetOffice metadata]public class _Items{ // // Zusammenfassung: // SupportByVersionAttribute Outlook, 9,10,11,12,14,15 This is a custom enumerator // from NetOffice [CustomEnumerator] public IEnumerator GetEnumerator();}


*Sebastian]]></BodyHtml>
      <CreatedAt>2015-02-10T18:15:49.0000000+01:00</CreatedAt>
    </CodeplexComment>
  </Comments>
  <ReportedBy>dgoodw01</ReportedBy>
  <ReportedAt>2015-01-29T14:52:43.0000000+00:00</ReportedAt>
</CodeplexIssue>